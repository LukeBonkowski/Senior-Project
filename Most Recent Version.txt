/*Senior Project
 *Authors: Luke B., Ryan P. & Will S.
 *Version_Date:1_9/23/2018 (Base/Bluetooth)
 *Version_Date:2_11/12/2018 (Ultrasonic)
 *Version_Date:3_1/22/2019 (Map/Bug fixes)
 *Version_Date:4_2/2/2019 (2nd Ultrasonic)
 *Version_Date:5_2/5/2019 (Formatting output)
 *Version_Date:6_3/1/2019 (Pathing Part 1)
 */

//Include Files
#include <stdint.h>
#include <stdbool.h>
#include <stdio.h>
#include <string.h>
//#include "tm4c123gh6pm.h"
#include "inc/hw_ints.h"
#include "inc/hw_memmap.h"
#include "inc/hw_timer.h"
#include "inc/hw_types.h"

#include "driverlib/adc.h"
#include "driverlib/debug.h"
#include "driverlib/fpu.h"
#include "driverlib/gpio.h"
#include "driverlib/interrupt.h"
#include "driverlib/pin_map.h"
#include "driverlib/rom.h"
#include "driverlib/sysctl.h"
#include "driverlib/systick.h"
#include "driverlib/timer.h"
#include "driverlib/uart.h"

#include "utils/uartstdio.h"


#define RED_LED            GPIO_PIN_1  // PF1
#define GREEN_LED          GPIO_PIN_3  // PF2
#define BLUE_LED           GPIO_PIN_2  // PF3

struct TwoBit
{
    bool bitA;
    bool bitB;
};



//Position Identifiers
uint8_t xPosition = 50; //We are using one central point for the position so that we can save on memory even though we will need to do minor calculation for updating the map
uint8_t yPosition = 0; //This may need to be changed if it isn't practical but starting at or near the bottom edge and orientating our maze appropriately will be our best bet.
//Angular Identifier
struct TwoBit Direction; // 00 = right, 01 = up, 10 = left, 11 = down.

//Internal Delay
uint32_t ui32Loop;
uint32_t MaxDelay = 200000;
uint8_t count = 0;
uint16_t i = 0;

uint8_t RedLedToggle = 0;
uint8_t GreenLedToggle = 0;
uint8_t BlueLedToggle = 0;

volatile uint32_t pulse=0;
volatile uint8_t echowait=0;

char string[50] = "Hi Will and Luke.";
char pulseString[8];

//Two Bit Map
const uint8_t width = 100; //maximum value of 255; use uint32 if you want up to 65,536.
const uint8_t height = 100; //note this is height in squares not cm's 
struct TwoBit map[width][height]; //these values are static so they should default to 0



void configUART(void);
void configUltrasonic1(void);
void configUltrasonic2(void);
void usInputInt1(void);
void usInputInt2(void);
void sendUltrasonic1(void);
void receiveUltrasonic2(void);
void setup(void);
void intToAscii(char[8]);
void sendMap(void);
void updateMap(uint32_t, uint32_t);//This assumes that the first int is the sensor that is looking foreword and the second int is the sensor looking to the right.
//Direction and movement
int DirectionDecision();
void RightTurn(void);
void LeftTurn(void);


int main(void)
{
    Direction.bitA = false;
    Direction.bitB = true;

    uint8_t count = 0;
    //40 MHz PLL config (25 nsec)
    SysCtlClockSet(SYSCTL_SYSDIV_5|SYSCTL_USE_PLL|SYSCTL_OSC_MAIN|SYSCTL_XTAL_16MHZ);

    //Timer config
    SysCtlPeripheralEnable(SYSCTL_PERIPH_TIMER0);
    TimerConfigure(TIMER0_BASE, TIMER_CFG_PERIODIC_UP);
    TimerEnable(TIMER0_BASE,TIMER_A);

    //Enables Port F
    SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);
    //LED Configuration
    GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, RED_LED|BLUE_LED|GREEN_LED);

    configUART();
    configUltrasonic1();
    configUltrasonic2();


    IntMasterEnable();

    //GPIOPinWrite(GPIO_PORTF_BASE, GREEN_LED, GREEN_LED);
    //Send 10 strings to test the bluetooth communication
    /*while (count < 10)
    {
        for (i = 0; i < 50; i++)
        {
            while(UARTBusy(UART3_BASE)) {;}
            UARTCharPut(UART3_BASE, string[i]);
        }
        count++;
    }//*/
    SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOB);
    GPIOPinTypeGPIOOutput(GPIO_PORTB_BASE, GPIO_PIN_3);
    GPIOPinWrite(GPIO_PORTB_BASE, GPIO_PIN_3, GPIO_PIN_3);
    while (1)
    {
        //For Delay (400/3) is 1 us because a delay is 3 cycle action and each clock cycle is 25 ns
        //SysCtlDelay((400/3)*200000);
        if (echowait != 1 && count == 0)
        {
            SysCtlDelay((400/3) * 1000); //delay for some time
            sendUltrasonic1();
            count++;
        }
        else if (echowait != 1 && count == 1)
        {
            SysCtlDelay((400/3) * 1000); //delay
            sendUltrasonic2();
            count--;
        }

        while (echowait != 0) {;}

        pulse = (uint32_t)(0.025*pulse); //clock cycle correction
        pulse = (pulse / 58) - 1; //convert to cm
        intToAscii(pulseString);
        while(UARTBusy(UART3_BASE)) {;}
        for (i = 0; i < 8; i++)
        {
            while(UARTBusy(UART3_BASE)) {;}
            UARTCharPut(UART3_BASE, pulseString[i]);
        }
        memset(pulseString,0,sizeof(pulseString));
       /* while(UARTBusy(UART3_BASE)) {;}
        UARTCharPut(UART3_BASE, ' ');  //*/
        if (count == 1)
        {
            while(UARTBusy(UART3_BASE)) {;}
            UARTCharPut(UART3_BASE, ' ');//
        }
        else
        {
            while(UARTBusy(UART3_BASE)) {;}
            UARTCharPut(UART3_BASE, (char)10);//  \r
            while(UARTBusy(UART3_BASE)) {;}
            UARTCharPut(UART3_BASE, (char)13);//  \n
        }   //*/
    }

    return 0;
}

void configUART(void)
{

    SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOC);
    SysCtlPeripheralEnable(SYSCTL_PERIPH_UART3);
    //GPIOPinConfigure(GPIO_PC6_U3RX);
    GPIOPinConfigure(GPIO_PC7_U3TX);
    /*HWREG(GPIO_PORTC_BASE + GPIO_O_LOCK) = GPIO_LOCK_KEY;
    HWREG(GPIO_PORTC_BASE + GPIO_O_CR) |= 0x06;
    HWREG(GPIO_PORTC_BASE + GPIO_O_LOCK) = 0;
    HWREG(GPIO_PORTC_BASE + GPIO_O_LOCK) = GPIO_LOCK_KEY;
    HWREG(GPIO_PORTC_BASE + GPIO_O_CR) |= 0x07;
    HWREG(GPIO_PORTC_BASE + GPIO_O_LOCK) = 0;*/
    //GPIOPinTypeUART(GPIO_PORTC_BASE, GPIO_PIN_6 | GPIO_PIN_7);
    GPIOPinTypeUART(GPIO_PORTC_BASE, GPIO_PIN_7);
    while(!SysCtlPeripheralReady(SYSCTL_PERIPH_GPIOC))
    {
    }
    UARTConfigSetExpClk(UART3_BASE, SysCtlClockGet(), 9600, (UART_CONFIG_WLEN_8 | UART_CONFIG_STOP_ONE | UART_CONFIG_PAR_NONE));
}

void configUltrasonic1(void)
{
    //Trig pin config
    SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOA);

    GPIOPinTypeGPIOOutput(GPIO_PORTA_BASE, GPIO_PIN_3);

    //Echo pin config
    SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOA);

    GPIOPinTypeGPIOInput(GPIO_PORTA_BASE, GPIO_PIN_2);
    GPIOIntEnable(GPIO_PORTA_BASE, GPIO_PIN_2);
    GPIOIntTypeSet(GPIO_PORTA_BASE, GPIO_PIN_2, GPIO_BOTH_EDGES);
    GPIOIntRegister(GPIO_PORTA_BASE,usInputInt1);
    GPIOIntEnable(GPIO_PORTA_BASE, GPIO_INT_PIN_2);
}

void usInputInt1(void)  //number of cycles per instruction
{
    GPIOIntClear(GPIO_PORTA_BASE, GPIO_PIN_2); //int clear   3

    if (GPIOPinRead(GPIO_PORTA_BASE, GPIO_PIN_2) == GPIO_PIN_2)// 5
    {
        //GPIOPinWrite(GPIO_PORTF_BASE, RED_LED, RED_LED);
        HWREG(TIMER0_BASE + TIMER_O_TAV) = 0;
        TimerEnable(TIMER0_BASE, TIMER_A);
        echowait = 1;
    }
    else
    {
        pulse = TimerValueGet(TIMER0_BASE, TIMER_A);  //5
        TimerDisable(TIMER0_BASE, TIMER_A);//  3
        echowait=0;//  3
        GPIOPinWrite(GPIO_PORTF_BASE, RED_LED, 0); //  4
    }
}

void sendUltrasonic1(void)
{
    GPIOPinWrite(GPIO_PORTA_BASE, GPIO_PIN_3, GPIO_PIN_3);
    SysCtlDelay(400/3); //delay for 10us
    GPIOPinWrite(GPIO_PORTA_BASE, GPIO_PIN_3, ~GPIO_PIN_3);
}

void configUltrasonic2(void)
{
    //Trig pin config
    SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOD);

    GPIOPinTypeGPIOOutput(GPIO_PORTD_BASE, GPIO_PIN_3);

    //Echo pin config
    SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOD);

    GPIOPinTypeGPIOInput(GPIO_PORTD_BASE, GPIO_PIN_2);
    GPIOIntEnable(GPIO_PORTD_BASE, GPIO_PIN_2);
    GPIOIntTypeSet(GPIO_PORTD_BASE, GPIO_PIN_2, GPIO_BOTH_EDGES);
    GPIOIntRegister(GPIO_PORTD_BASE,usInputInt2);
    GPIOIntEnable(GPIO_PORTD_BASE, GPIO_INT_PIN_2);
}

void usInputInt2(void)
{
    GPIOIntClear(GPIO_PORTD_BASE, GPIO_PIN_2); //int clear

    if (GPIOPinRead(GPIO_PORTD_BASE, GPIO_PIN_2) == GPIO_PIN_2)
    {
        //GPIOPinWrite(GPIO_PORTF_BASE, RED_LED, RED_LED);
        HWREG(TIMER0_BASE + TIMER_O_TAV) = 0;
        TimerEnable(TIMER0_BASE, TIMER_A);
        echowait = 1;
    }
    else
    {
        pulse = TimerValueGet(TIMER0_BASE, TIMER_A);
        TimerDisable(TIMER0_BASE, TIMER_A);
        echowait=0;
        GPIOPinWrite(GPIO_PORTF_BASE, RED_LED, 0);
    }
}

void sendUltrasonic2(void)
{
    GPIOPinWrite(GPIO_PORTD_BASE, GPIO_PIN_3, GPIO_PIN_3);
    SysCtlDelay(400/3); //delay for 10us
    GPIOPinWrite(GPIO_PORTD_BASE, GPIO_PIN_3, ~GPIO_PIN_3);
}

void intToAscii(char pulseString[8])
{
    int number = pulse;
    uint8_t i = 0;
    if(number == 0)
    {
        pulseString[0] = '0';
    }
    while (number > 0)
    {
        number = number / 10;
        i++; //
    }
    number = pulse;
    //while (i > 0)
    while (number > 0)
        {
            pulseString[i - 1] = (char)((number % 10) + 48);
            number = number / 10;
            i--;
    }
}

void sendMap(void)
{
    uint16_t widthIndex;
    uint16_t heightIndex;
    

    for (heightIndex = 0; heightIndex < height; heightIndex++)
    {
        for (widthIndex = 0; widthIndex < width; widthIndex++)
        {
            currentNumber = map[widthIndex][heightIndex];
            if (map[widthIndex][heightIndex].bitA == false)
            {
                while(UARTBusy(UART3_BASE)) {;}
                UARTCharPut(UART3_BASE, '0');
                
            }
            else
            {
                while(UARTBusy(UART3_BASE)) {;}
                UARTCharPut(UART3_BASE, '1');
            }
			if (map[widthIndex][heightIndex].bitB == false)
			{
				while(UARTBusy(UART3_BASE)) {;}
                UARTCharPut(UART3_BASE, '0');
				while(UARTBusy(UART3_BASE)) {;}
                UARTCharPut(UART3_BASE, ',');
			}
			else
			{
				while(UARTBusy(UART3_BASE)) {;}
                UARTCharPut(UART3_BASE, '1');
				while(UARTBusy(UART3_BASE)) {;}
                UARTCharPut(UART3_BASE, ',');
			}

        }
        while(UARTBusy(UART3_BASE)) {;}
        UARTCharPut(UART3_BASE, (char)10);//  \r
        while(UARTBusy(UART3_BASE)) {;}
        UARTCharPut(UART3_BASE, (char)13);//  \n
    }
}
/*
void updateMap (uint32_t ForeSensorPulse, uint32_t RightSensorPulse)
{
	int squaresAway  //how many squares away the wall found was
	if(RightSensorPulse > 0)
	{
		int squaresAway = RightSensorPulse / 2;
		for(int z = 1; z <= squaresAway; z++)
		{
			if(z != squaresAway)
			{
				map[][].bitA = false;
			}
		}
		
	}
	else 
		; //don't update because we got a bad value
	if(ForeSensorPulse > 0)
	{
		int ForeSquares = ForeSensorPulse / 2;
	}
	map[][]
}

void RightTurn (void)
{
   //Do the function name
}

void LeftTurn (void)
{

}

int DirectionDecision ()
{

}
*/
